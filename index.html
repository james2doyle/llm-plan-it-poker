<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan It Poker - Magic Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Include Alpine.js from CDN with defer attribute -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        /* Base styles for the body and game container */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scroll during swipe */
        }

        .game-container {
            width: 100%;
            max-width: 400px; /* Card width */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        /* Card stack for visual layering */
        .card-stack {
            position: relative;
            width: 100%;
            height: 550px; /* Card height */
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 2rem;
        }

        /* Styling for an individual Magic-themed card */
        .magic-card {
            background-color: #2d3748; /* Darker card background */
            border: 4px solid #a0aec0; /* Grey border for MtG feel */
            border-radius: 15px;
            padding: 1rem;
            width: 100%;
            max-width: 350px; /* Card width */
            height: 500px; /* Card height */
            display: flex;
            flex-direction: column;
            position: absolute;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out; /* Smooth transitions for swipe */
            cursor: grab;
            user-select: none;
            will-change: transform; /* Optimize for animation */
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-weight: bold;
            font-size: 1.125rem; /* text-lg */
        }

        .card-name {
            color: #f7fafc; /* White text */
        }

        /* Mana cost display */
        .mana-cost {
            display: flex;
            gap: 0.25rem;
        }

        .mana-symbol {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: black;
            border: 1px solid black;
        }
        /* Specific mana symbol colors */
        .mana-W { background-color: #f9f6e6; } /* White */
        .mana-U { background-color: #a0d5ee; } /* Blue */
        .mana-B { background-color: #6a6a6a; } /* Black */
        .mana-R { background-color: #f08080; } /* Red */
        .mana-G { background-color: #90ee90; } /* Green */
        .mana-C { background-color: #d3d3d3; } /* Colorless */
        .mana-T { background-color: #d3d3d3; } /* Tap symbol, treat as colorless */


        /* Card image styling */
        .card-image-container {
            width: 100%;
            height: 180px;
            background-color: #4a5568; /* Dark grey placeholder */
            border: 2px solid #a0aec0;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Card type line styling */
        .card-type-line {
            font-style: italic;
            margin-bottom: 0.5rem;
            color: #cbd5e0;
            font-size: 0.875rem; /* text-sm */
        }

        /* Text box for card rules and details */
        .card-text-box {
            background-color: #1a202c; /* Inner dark background */
            border: 2px solid #a0aec0;
            border-radius: 8px;
            padding: 0.75rem;
            flex-grow: 1;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            line-height: 1.3;
            overflow-y: auto; /* For long text */
        }

        .flavor-text {
            font-style: italic;
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #a0aec0;
        }

        /* Power/Defense display */
        .power-defense {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            font-weight: bold;
            font-size: 1.25rem; /* text-xl */
            color: #f7fafc;
            border: 2px solid #a0aec0;
            border-radius: 8px;
            padding: 0.25rem 0.5rem;
            background-color: #1a202c;
            align-self: flex-end; /* Align to bottom right */
            margin-top: auto; /* Push to bottom */
        }

        /* Swipe visual indicators */
        .swipe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none; /* Allows clicks/touches to pass through unless actively swiping */
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .swipe-indicator {
            padding: 1rem;
            border-radius: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            opacity: 0.7;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .swipe-left-indicator {
            background-color: rgba(220, 38, 38, 0.7); /* Red */
        }

        .swipe-right-indicator {
            background-color: rgba(34, 197, 94, 0.7); /* Green */
        }

        /* Current game info display */
        .current-info {
            font-size: 1.125rem;
            font-weight: bold;
            margin-top: 1rem;
            text-align: center;
            color: #a0aec0;
        }

        /* End game screen styling */
        .end-screen {
            background-color: #2d3748;
            border: 4px solid #a0aec0;
            border-radius: 15px;
            padding: 2rem;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .end-screen h2 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: #f7fafc;
        }

        .ranked-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .ranked-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: #1a202c;
            border-radius: 8px;
            border: 1px solid #4a5568;
        }

        .ranked-list-item span {
            font-size: 1.125rem;
            color: #f7fafc;
        }

        .ranked-list-item strong {
            color: #63b3ed; /* Blue for rank */
        }

        /* Restart button styling */
        .restart-button {
            background-color: #63b3ed; /* Blue */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease-in-out;
        }

        .restart-button:hover {
            background-color: #4299e1;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            .game-container {
                padding: 0.5rem;
            }
            .magic-card {
                padding: 0.75rem;
                height: 480px;
            }
            .card-stack {
                height: 530px;
            }
            .card-header {
                font-size: 1rem;
            }
            .mana-symbol {
                width: 18px;
                height: 18px;
                font-size: 0.65rem;
            }
            .card-image-container {
                height: 160px;
            }
            .card-type-line {
                font-size: 0.8rem;
            }
            .card-text-box {
                font-size: 0.85rem;
                padding: 0.6rem;
            }
            .flavor-text {
                font-size: 0.75rem;
            }
            .power-defense {
                font-size: 1.1rem;
            }
            .swipe-indicator {
                font-size: 1.2rem;
                padding: 0.75rem;
            }
            .current-info {
                font-size: 1rem;
            }
            .end-screen h2 {
                font-size: 1.75rem;
            }
            .ranked-list-item span {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container" class="game-container" x-data="gameData" x-init="loadCardsAndInit()">
        <!-- Displays current round and card info -->
        <div id="current-info" class="current-info" x-text="`Round ${roundNumber} | Cards Remaining: ${currentRoundCards.length - currentCardIndex}/${currentRoundCards.length} | Current Rank Value: +${roundNumber}`"></div>

        <!-- Area where cards are displayed and swiped -->
        <div id="card-stack" class="card-stack" :class="{'hidden': showEndScreen}">
            <!-- Loop through cards to display a stack effect -->
            <template x-for="(card, index) in currentRoundCards.slice(currentCardIndex)" :key="card.id">
                <div class="magic-card"
                    :data-card-id="card.id"
                    :style="{ 'z-index': currentRoundCards.length - index, 'top': `${index * 5}px`, 'left': `${index * 5}px`, 'transform': card.transformStyle, 'opacity': card.opacityStyle }"
                    @mousedown="startDrag($event, card.id)"
                    @touchstart="startDrag($event, card.id)"
                    @mousemove="drag($event, card.id)"
                    @touchmove="drag($event, card.id)"
                    @mouseup="endDrag(card.id)"
                    @touchend="endDrag(card.id)"
                    @mouseleave="isDragging && endDrag(card.id)"
                >
                    <div class="card-header">
                        <span class="card-name" x-text="card.name[0]"></span>
                        <div class="mana-cost" x-html="parseManaCost(card.mana_cost)"></div>
                    </div>
                    <div class="card-header mb-2 text-sm italic font-normal">
                        <span class="text-gray-400" x-text="card.name[1]"></span>
                    </div>
                    <div class="card-image-container">
                        <img :src="card.image_url" :alt="card.image_description" class="card-image" onerror="this.onerror=null; this.src='https://placehold.co/350x180/4a5568/e2e8f0?text=Image+Not+Found';" loading="lazy">
                    </div>
                    <div class="card-type-line" x-text="`${card.card_type} — ${card.card_subtypes.join(' ')}`"></div>
                    <div class="card-text-box">
                        <p class="mb-2" x-text="card.card_text"></p>
                        <p class="text-gray-400 font-bold">Impact: <span class="font-normal" x-text="card.estimated_impact_to_project"></span></p>
                        <p class="text-gray-400 font-bold">Size: <span class="font-normal" x-text="card.estimated_t_shirt_size_to_build"></span></p>
                    </div>
                    <div class="flavor-text" x-text="card.flavor_text"></div>
                    <template x-if="card.power_defense && card.power_defense.length === 2">
                        <div class="power-defense" x-text="`${card.power_defense[0]}/${card.power_defense[1]}`"></div>
                    </template>

                    <!-- Overlay for swipe indicators -->
                    <div class="swipe-overlay" :style="{ 'opacity': card.overlayOpacity }">
                        <div class="swipe-indicator swipe-left-indicator -ml-8 rotate-45" :style="{ 'opacity': card.leftIndicatorOpacity }" style="transform-origin: left center;">Decrease Rank</div>
                        <div class="swipe-indicator swipe-right-indicator -mr-8 -rotate-45" :style="{ 'opacity': card.rightIndicatorOpacity }" style="transform-origin: right center;">Increase Rank</div>
                    </div>
                </div>
            </template>
        </div>

        <!-- End screen, hidden until the game finishes -->
        <div id="end-screen" class="end-screen" :class="{'hidden': !showEndScreen}">
            <h2>Final Rankings</h2>
            <ul id="ranked-list" class="ranked-list">
                <template x-for="card in sortedCards" :key="card.id">
                    <li class="ranked-list-item">
                        <span x-text="card.name[0]"></span>
                        <strong x-text="`Rank: ${card.finalRank}`"></strong>
                    </li>
                </template>
            </ul>
            <button id="restart-button" class="restart-button" @click="initGame()">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('gameData', () => ({
                allCards: [], // All original cards with their evolving rank states
                currentRoundCards: [], // Cards currently active in the current ranking round
                currentCardIndex: 0, // Index of the card being displayed in the currentRoundCards
                roundNumber: 1, // Tracks the current round, used to increment rank for 'right' swipes
                showEndScreen: false, // Controls visibility of the end game screen
                sortedCards: [], // Array to hold cards sorted by final rank for the end screen

                // State for drag/swipe logic
                isDragging: false,
                startX: 0,
                currentX: 0,
                swipeThreshold: 80, // Minimum pixels to drag to register a swipe
                rotationFactor: 0.05, // Factor to apply rotation based on horizontal drag

                /**
                 * Loads card data from a JSON file and then initializes the game.
                 */
                async loadCardsAndInit() {
                    try {
                        // Assuming cards.json is in the same directory as index.html
                        const response = await fetch('./cards.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        this.allCards = data.map((card, index) => ({
                            ...card,
                            id: `card-${index}`, // Assign a unique ID to each card
                            currentRank: 0, // Rank accumulating within rounds
                            finalRank: -1, // Final rank assigned when a card is 'swiped left' or at game end
                            swipedRightInRound: false, // Flag to determine if card proceeds to next round
                            transformStyle: 'translateX(0) rotate(0deg)', // Initial transform for CSS
                            opacityStyle: 1, // Initial opacity for CSS
                            overlayOpacity: 0, // Initial opacity for swipe indicators
                            leftIndicatorOpacity: 0,
                            rightIndicatorOpacity: 0,
                        }));
                        this.initGame(); // Initialize the game once data is loaded
                    } catch (error) {
                        console.error("Failed to load card data:", error);
                        // You might want to display a user-friendly error message here
                    }
                },

                /**
                 * Initializes or restarts the game to its default state.
                 * Assumes this.allCards has already been populated from a fetch call.
                 */
                initGame() {
                    // Reset all card states for a fresh game, using the already loaded allCards
                    this.allCards = this.allCards.map(card => ({
                        ...card,
                        currentRank: 0,
                        finalRank: -1,
                        swipedRightInRound: false,
                        transformStyle: 'translateX(0) rotate(0deg)',
                        opacityStyle: 1,
                        overlayOpacity: 0,
                        leftIndicatorOpacity: 0,
                        rightIndicatorOpacity: 0,
                    }));
                    // All cards start in the first round
                    this.currentRoundCards = [...this.allCards];
                    this.currentCardIndex = 0;
                    this.roundNumber = 1;
                    this.showEndScreen = false;
                    this.sortedCards = [];
                },

                /**
                 * Parses mana cost strings (e.g., "{2}{W}{U}") into HTML elements representing mana symbols.
                 * @param {string[]} manaCostArray - An array containing the mana cost string.
                 * @returns {string} HTML string for mana symbols.
                 */
                parseManaCost(manaCostArray) {
                    if (!manaCostArray || manaCostArray.length === 0) return '';
                    const costString = manaCostArray[0];
                    const regex = /\{(\d+)\}|\{([WUBRGCT])\}/g;
                    let match;
                    let resultHtml = '';
                    while ((match = regex.exec(costString)) !== null) {
                        if (match[1]) { // Numeric mana (e.g., {2})
                            resultHtml += `<span class="mana-symbol mana-C">${match[1]}</span>`;
                        } else if (match[2]) { // Color mana (e.g., {W}, {U}, {B}, {R}, {G}, {T} for tap)
                            resultHtml += `<span class="mana-symbol mana-${match[2]}">${match[2]}</span>`;
                        }
                    }
                    return resultHtml;
                },

                /**
                 * Starts the drag operation for a card.
                 * @param {Event} e - The mouse or touch event.
                 * @param {string} cardId - The ID of the card being dragged.
                 */
                startDrag(e, cardId) {
                    this.isDragging = true;
                    // Prevent default to avoid text selection on desktop or scrolling on mobile
                    e.preventDefault();

                    this.startX = e.clientX || e.touches[0].clientX;
                    const card = this.allCards.find(c => c.id === cardId);
                    if (card) {
                        // Reset transform and transition for immediate drag response
                        card.transformStyle = 'translateX(0) rotate(0deg)';
                        card.opacityStyle = 1;
                    }
                },

                /**
                 * Handles the dragging movement of a card.
                 * @param {Event} e - The mouse or touch event.
                 * @param {string} cardId - The ID of the card being dragged.
                 */
                drag(e, cardId) {
                    if (!this.isDragging) return;

                    const clientX = e.clientX || e.touches[0].clientX;
                    this.currentX = clientX - this.startX;

                    const card = this.allCards.find(c => c.id === cardId);
                    if (card) {
                        card.transformStyle = `translateX(${this.currentX}px) rotate(${this.currentX * this.rotationFactor}deg)`;

                        const opacity = Math.min(Math.abs(this.currentX) / this.swipeThreshold, 1);
                        card.overlayOpacity = opacity;
                        if (this.currentX < 0) { // Swiping left
                            card.leftIndicatorOpacity = opacity;
                            card.rightIndicatorOpacity = 0;
                        } else { // Swiping right
                            card.rightIndicatorOpacity = opacity;
                            card.leftIndicatorOpacity = 0;
                        }
                    }
                },

                /**
                 * Ends the drag operation and processes the swipe.
                 * @param {string} cardId - The ID of the card being swiped.
                 */
                endDrag(cardId) {
                    if (!this.isDragging) return;
                    this.isDragging = false;

                    const card = this.allCards.find(c => c.id === cardId);
                    if (!card) return;

                    // Reset indicator opacities immediately
                    card.overlayOpacity = 0;
                    card.leftIndicatorOpacity = 0;
                    card.rightIndicatorOpacity = 0;

                    if (this.currentX > this.swipeThreshold) {
                        this.handleCardSwipe(card, 'right');
                    } else if (this.currentX < -this.swipeThreshold) {
                        this.handleCardSwipe(card, 'left');
                    } else {
                        // Reset card position if swipe threshold not met
                        card.transformStyle = 'translateX(0) rotate(0deg)';
                        card.opacityStyle = 1;
                    }
                    this.currentX = 0; // Reset currentX for next drag
                },

                /**
                 * Handles the logic after a card is swiped (left or right).
                 * @param {Object} card - The card object that was swiped.
                 * @param {string} direction - 'left' or 'right' indicating the swipe direction.
                 */
                handleCardSwipe(card, direction) {
                    if (direction === 'right') {
                        card.currentRank += this.roundNumber;
                        card.swipedRightInRound = true;
                        card.transformStyle = 'translateX(200%) rotate(30deg)';
                    } else {
                        card.finalRank = card.currentRank;
                        card.swipedRightInRound = false;
                        card.transformStyle = 'translateX(-200%) rotate(-30deg)';
                    }
                    card.opacityStyle = 0; // Fade out

                    // Use setTimeout to allow the transition to complete before moving to next card
                    setTimeout(() => {
                        this.currentCardIndex++;
                        if (this.currentCardIndex >= this.currentRoundCards.length) {
                            this.startNextRound();
                        }
                    }, 500); // Match this duration to the CSS transition duration
                },

                /**
                 * Manages the transition to the next round of ranking or ends the game.
                 */
                startNextRound() {
                    const nextRoundCandidates = this.currentRoundCards.filter(card => card.swipedRightInRound);

                    if (nextRoundCandidates.length <= 1) {
                        nextRoundCandidates.forEach(card => {
                            if (card.finalRank === -1) {
                                card.finalRank = card.currentRank;
                            }
                        });
                        this.endGame();
                        return;
                    }

                    const ranksInNextRound = nextRoundCandidates.map(c => c.currentRank);
                    const uniqueRanks = new Set(ranksInNextRound);

                    if (uniqueRanks.size === nextRoundCandidates.length) {
                        nextRoundCandidates.forEach(card => {
                            if (card.finalRank === -1) {
                                card.finalRank = card.currentRank;
                            }
                        });
                        this.endGame();
                        return;
                    }

                    this.roundNumber++;
                    this.currentRoundCards = nextRoundCandidates.map(card => {
                        // Reset temporary visual styles and swipedRightInRound flag
                        card.transformStyle = 'translateX(0) rotate(0deg)';
                        card.opacityStyle = 1;
                        card.overlayOpacity = 0;
                        card.leftIndicatorOpacity = 0;
                        card.rightIndicatorOpacity = 0;
                        card.swipedRightInRound = false;
                        return card;
                    });
                    this.currentCardIndex = 0;
                },

                /**
                 * Ends the game, calculates final ranks, and displays the sorted list.
                 */
                endGame() {
                    this.allCards.forEach(card => {
                        if (card.finalRank === -1) {
                            card.finalRank = card.currentRank;
                        }
                    });

                    this.sortedCards = [...this.allCards].sort((a, b) => b.finalRank - a.finalRank);
                    this.showEndScreen = true;
                }
            }));
        });
    </script>
</body>
</html>